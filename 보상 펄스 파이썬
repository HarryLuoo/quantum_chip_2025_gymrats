import numpy as np
import qutip as qt
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D  # for 3D Bloch

# --- 1. SYSTEM & PULSE DEFINITIONS (with compensation) ---
N = 3
target = 1
w_q     = 5.0 * 2*np.pi    # qubit freq (rad/ns)
Omega   = 10.0 * 2*np.pi   # main drive Rabi
J       = 0.1 * Omega      # inherent crosstalk coupling
# compensation pulse amplitude = J, inverted phase
Omega_c = J

t_total = 100.0
t0, tau = 50.0, 5.0

def drive_env(t, args):
    return np.exp(- (t-args['t0'])**2 / (2*args['tau']**2))

def comp_env(t, args):
    return np.exp(- (t-args['t0'])**2 / (2*args['tau']**2))

# decoherence
T1, T2 = 50e3, 10e3
γ1, γ2 = 1/T1, 1/T2

# Pauli operators
sx = [qt.tensor(*([qt.qeye(2)]*i + [qt.sigmax()] + [qt.qeye(2)]*(N-1-i)))
      for i in range(N)]
sy = [qt.tensor(*([qt.qeye(2)]*i + [qt.sigmay()] + [qt.qeye(2)]*(N-1-i)))
      for i in range(N)]
sz = [qt.tensor(*([qt.qeye(2)]*i + [qt.sigmaz()] + [qt.qeye(2)]*(N-1-i)))
      for i in range(N)]
sm = [qt.tensor(*([qt.qeye(2)]*i + [qt.sigmam()] + [qt.qeye(2)]*(N-1-i)))
      for i in range(N)]

H0      = sum(-0.5*w_q*sz[i] for i in range(N))
H_drive =  Omega   * sx[target]
H_xtlk  =  J       * (sx[target-1]*sx[target] + sx[target]*sx[target+1])
H_comp  = -Omega_c * (sx[target-1]*sx[target] + sx[target]*sx[target+1])

H = [
    H0,
    [H_drive + H_xtlk, drive_env],
    [H_comp,             comp_env]
]

c_ops = []
for i in range(N):
    c_ops += [np.sqrt(γ1)*sm[i], np.sqrt(γ2)*sz[i]]

psi0  = qt.tensor(*[qt.basis(2,0) for _ in range(N)])
tlist = np.linspace(0, t_total, 201)
args  = {'t0': t0, 'tau': tau}

print("Running compensated simulation…")
result = qt.mesolve(H, psi0, tlist, c_ops, [], args=args)
print("Done.")

# compute Bloch expectations
exp_x = [qt.expect(sx[i], result.states) for i in range(N)]
exp_y = [qt.expect(sy[i], result.states) for i in range(N)]
exp_z = [qt.expect(sz[i], result.states) for i in range(N)]

# precalc pulse envelopes
drive_vals = drive_env(tlist, args)
comp_vals  = -Omega_c/Omega * drive_vals  # scaled inverted

# --- 2. SETUP FIGURE: left=pulses, right=3 Bloch spheres ---
fig = plt.figure(figsize=(12,6))

# left: pulses with enhanced visibility
ax_p = fig.add_subplot(2, 1, 1)
ax_p.plot(tlist, drive_vals,  label='Main Drive B-field',     color='tab:blue',   lw=3)
ax_p.fill_between(tlist, 0, drive_vals, color='tab:blue', alpha=0.1)
ax_p.plot(tlist, comp_vals,   '--', label='Compensation B-field', color='tab:orange', lw=3)
ax_p.fill_between(tlist, 0, comp_vals,  color='tab:orange', alpha=0.1)
ax_p.set_ylabel('Normalized Magnetic Field Intensity', fontsize=12)
ax_p.set_xlim(0, t_total)
ax_p.legend(loc='upper right', fontsize=11)
pulse_marker = ax_p.axvline(0, color='k', lw=2)

# right: three Bloch spheres
axes = []
colors = ['green','brown','blue']
for i in range(N):
    ax = fig.add_subplot(2, N, N + i + 1, projection='3d')
    ax.set_box_aspect((1,1,1))
    ax.set_title(f"Qubit {i}")
    ax.set_xlim(-1,1); ax.set_ylim(-1,1); ax.set_zlim(-1,1)
    u = np.linspace(0,2*np.pi,60); v = np.linspace(0, np.pi,30)
    x = np.outer(np.cos(u), np.sin(v))
    y = np.outer(np.sin(u), np.sin(v))
    z = np.outer(np.ones_like(u), np.cos(v))
    ax.plot_wireframe(x, y, z, color='lightgray', alpha=0.3)
    axes.append(ax)

# storage for arrows
arts = []

def init():
    return []

def update(k):
    t = tlist[k]
    pulse_marker.set_xdata([t, t])
    for a in arts:
        a.remove()
    arts.clear()

    for i, ax in enumerate(axes):
        x, y, z = exp_x[i][k], exp_y[i][k], exp_z[i][k]
        a = ax.quiver(0,0,0, x,y,z,
                      color=colors[i], lw=2.5,
                      arrow_length_ratio=0.15)
        arts.append(a)
    return [pulse_marker] + arts

ani = FuncAnimation(fig, update,
                    frames=len(tlist),
                    init_func=init,
                    blit=False,
                    interval=50)

ani.save('crosstalk_compensation_anim_enhanced.gif', writer='pillow', fps=20)
plt.show()
